<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/hh.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/hh.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/hh.github.io/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/hh.github.io/favicon.ico?v=5.1.2" />






<meta name="description" content="技术沉淀">
<meta property="og:type" content="website">
<meta property="og:title" content="src">
<meta property="og:url" content="https://wangamama.github.io/hh.github.io/index.html">
<meta property="og:site_name" content="src">
<meta property="og:description" content="技术沉淀">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="src">
<meta name="twitter:description" content="技术沉淀">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hh.github.io/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangamama.github.io/hh.github.io/"/>





  <title>src</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hh.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">src</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个程序员, 文学爱好者的思考</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hh.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hh.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangamama.github.io/hh.github.io/hh.github.io/2017/09/19/谈谈Mysql表结构的设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="号号(个人邮箱a981945164@163.com，不当之处请指正)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hh.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="src">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hh.github.io/2017/09/19/谈谈Mysql表结构的设计/" itemprop="url">谈谈Mysql表结构的设计(如何存储URL等)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T15:52:09+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字段类型的选择"><a href="#字段类型的选择" class="headerlink" title="字段类型的选择"></a>字段类型的选择</h2><ol>
<li><p>更小，节省存储空间；能用tiny int不用Int，更小的有利于提升检索速度。</p>
</li>
<li><p>简单(使用整形存储IP，整形肯定比字符串类型操作更快)<br>用UNSINGED INT存储IP地址占用4字节，CHAR(15)则占用15字节。另外，计算机处理整数类型比字符串类型快。使用INT UNSIGNED而不是CHAR(15)来存储IPV4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。IPv6地址目前没有转化函数，需要使用DECIMAL或两个BIGINT来存储。</p>
</li>
<li><p>避免NULL；<br>可为null的列会使用更多的存储空间，也需要特殊的处理。当可为null的列做索引的时候，每个索引记录需要一个额外的字节。在MYISAM引擎中，可能会导致固定大小的索引（如只有一个整数列的索引）变成可变大小的索引。<br>在数据库优化中，将null改为not null，带来的性能提升并不是很大，但是如果该列上有索引，那么需要避免设计为null.<br>但是也有例外，<strong>InnoDB使用单独的bit存储Null值，所以对稀疏数据有很好的空间效率，不同于MYISAM</strong>。</p>
</li>
<li><p>存储年使用YEAR类型。存储日期使用DATE类型。存储时间(精确到秒)建议使用TIMESTAMP类型。 TIMESTAMP保存了从1970.1.1以来的秒数。FROM-UNIXTIME()可以将UNIX时间戳转化为日期,UNIX_TIMESTAMP()函数将日期转化为UNIX时间戳。<br>DATETIME和TIMESTAMP都是精确到秒，优先选择TIMESTAMP，因为TIMESTAMP只有4个字节，而DATETIME8个字节。同时TIMESTAMP具有自动赋值以及⾃自动更新的特性。注意：在5.5和之前的版本中，如果一个表中有多个timestamp列，那么最多只能有一列能具有自动更新功能。<br>如何使用TIMESTAMP的自动赋值属性?<br>自动初始化，而且自动更新：<br>column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP<br>只是自动初始化：<br>column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP<br>自动更新，初始化的值为0：<br>column1 TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP</p>
</li>
<li><p>使用ENUM代替字符串的类型<br>其实际在数据表中存储的是数字序号，所以其排序是按照内部的存储的整数进行排序。枚举最不好的地方就是列表是固定的，如果要修改列表，就需要修改table,而且将枚举与char进行关联可能会比char关联char列更慢。如果在应用场景适合的情况下，应该使用enum。<br>create table t(e ENUM(“a”,”b”) not null)</p>
</li>
<li><p>为什么不应该使用字符串类型作为主键<br>因为插入值会随机的写到索引的不同位置，使得Insert很慢，这会导致页分裂，磁盘随机访问(因为需要先找到需要插入的位置读入内存，所以肯定会引起随机IO)，以及对于聚簇存储引擎产生的聚簇索引碎片.<br>Select会变慢，因为逻辑上相邻的行会分布在磁盘和内存上的不同位置。<br>随机性导致缓存对于所有类型的查询语句的效果都很差，因为缓存赖以工作的访问局部性原理失效。这个原理特别重要。<br><strong>我觉得，如果表的数据很少，使用自定义字符串的类型定义主键，可能会为业务上带来很大的方便。要视使用场景而定。</strong><br>如果使用uuid作为主键那么必须去掉-符号，更好的做法是UNHX()函数将其转化为16字节的数字。使用uuid，当我们明确需要分库分表的时候，采用uuid作为主键，有利于扩展性。<br><strong>其实自增的主键当并发量比较高的时候，生成唯一的自增序列也需要很大的消耗。</strong></p>
</li>
<li><p>Blob和TEXT是为存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。Mysql会对这两种类型做特殊的处理，当text或者blob过大的时候，mysql会有专门的存储区域存储数据，而在行内存储指向数据的指针(1到4个指针)。<br>当长度超过5000的时候，就要使用TEXT，而且要注意的是使用TEXT要独立一张表出来，避免影响其他字段索引的效率。</p>
</li>
<li><p>varchar与char的区别：<br>varchar采用额外的一到两个字节记录字符串的长度，例如varchar(1000)实际上使用了1002个字节。<br>varchar的最大缺点就是：因为长度是可变的，行变长时，如果页内没有更多的空间可以存储，MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内(InnoDB不会出现行碎片，InnoDB 会移动短小的行并重写到一个新的片段中，参见索引那个博客有仔细讲过)，所以就会导致碎片的问题。<br>如果字符串是基本定长的，采用char将能获得更好的性能，因为不易产生碎片的问题。但是有一定有注意，<strong>char会去掉字符串末尾的空格</strong>。</p>
</li>
<li><p>建表必有三个字段，id, create_time,modified_time，主键(big int),创建时间，最近修改一次的时间。我本人还喜欢在建表的时候，加一个remark的备注字段，因为在做项目的过程中，往往会出现字段不够用的情况，但是不利于其他人维护。</p>
</li>
<li><p>如何存储小数：<br>小数类型为 decimal，禁止使用 float 和 double。 float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不<br>正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。<br>为什么浮点数不能精确计算？</p>
<h2 id="如何存储URL-伪哈希索引"><a href="#如何存储URL-伪哈希索引" class="headerlink" title="如何存储URL(伪哈希索引)"></a>如何存储URL(伪哈希索引)</h2></li>
</ol>
<p>这个场景在我们之前的项目中出现过，之前项目的需求是生成大量的短连接，然后当用户通过短连接访问的时候，就需要查询该短连接所在的行里面的数据。如何快速检索呢？</p>
<p>在介绍我们的处理办法之前，先介绍一下mysql里面的另外一种索引hash索引：<br>在 MySQL 中，只有 Memory 引擎显式支持哈希索引。 Memory 引擎是支持 非唯一哈希索引的。</p>
<pre><code class="sql"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hash_test (
fname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
lname <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
<span class="keyword">KEY</span> <span class="keyword">USING</span> <span class="keyword">HASH</span> (fname) 
) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;
</code></pre>
<p>哈希索引的限制：</p>
<p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</p>
<p>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p>
<p>哈希索引只支持等值比较查询，包括 =、 IN()、 &lt;⇒(注意 &lt;&gt; 和 &lt;=&gt; 是不同的操作, &lt;=&gt;像常规的=运算符一样，两个值进行比较，结果是0（不等于）或1（相等）;换句话说：’A’&lt;=&gt;’B’得0和’a’&lt;=&gt;’a‘得1,但是和=运算符不同的是，NULL的值是没有任何意义的。所以=号运算符不能把NULL作为有效的结果。所以：请使用&lt;=&gt;，’a’ &lt;=&gt; NULL 得0   NULL&lt;=&gt; NULL 得出 1)。</p>
<p>访问哈希索引的数据非常快，除非有很多哈希冲突。哈希冲突时使用链表来解决哈希冲突。</p>
<p>如果哈希冲突很多的话，一些所以维护操作的代价也会很高。冲突越多，代价越大。</p>
<p>因为这些限制，哈希索引只适用于某些特定的场合。而一旦适合哈希索引，则它带来的性能提升将非常显著。</p>
<p>如果存储引擎不支持哈希索引，可以模拟 InnoDB 一样创建哈希索引。思路：在 B-Tree 基础上创建一个伪哈希索引。并不是真正的哈希索引，本质还是使用 B-Tree 进行查找，但它使用哈希值而不是键本身进行查找。需要做的就是在查询的 WHERE 子句中手动指定使用哈希函数。<br>以下举个例子，展示下hash索引的结构，f表示哈希函数<br>f(“a”) =123;所在行是第一行<br>f(“b”) =124;所在行是第二行<br>哈希的结构为<br>key    value<br>123    指向第一行的指针<br>124    指向第二行的指针</p>
<pre><code class="sql">   <span class="keyword">SELECT</span> <span class="keyword">id</span>
<span class="keyword">FROM</span> <span class="keyword">url</span>
<span class="keyword">WHERE</span> <span class="keyword">url</span>=<span class="string">'http://www.diguage.com/'</span>;
<span class="comment">-- 创建自定义哈希索引</span>
<span class="comment">-- 注意：这里需要在 url_crc 字段上创建索引</span>
<span class="keyword">SELECT</span> <span class="keyword">id</span>
<span class="keyword">FROM</span> <span class="keyword">url</span>
<span class="keyword">WHERE</span> <span class="keyword">url</span>=<span class="string">'http://www.diguage.com/'</span>
    <span class="keyword">AND</span> url_crc=<span class="keyword">CRC32</span>(<span class="string">'http://www.diguage.com/'</span>);//url='http://www.diguage.com/'是必须的，好比hashmap里面的equals
</code></pre>
<p>自定义哈希索引的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。示例如下：</p>
<pre><code class="sql"><span class="comment">-- 插入触发器</span>
<span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> url_crc_ins
<span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="keyword">url</span>
<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span>
  <span class="keyword">SET</span> new.url_crc = <span class="keyword">crc32</span>(new.url);
<span class="keyword">END</span>;
<span class="comment">-- 更新触发器</span>
<span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> url_crc_upd
<span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="keyword">url</span>
<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span>
  <span class="keyword">SET</span> new.url_crc = <span class="keyword">crc32</span>(new.url);
<span class="keyword">END</span>;
</code></pre>
<p>采用这种方式，记住不要使用 SHA1() 和 MD5() 作为哈希函数。因为这两个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，更新时也会更慢。 SHA1() 和 MD5() 是强加密算法，设计目标是最大限度消除冲突，但这里并不需要这样高的要求。简单哈希函数的冲突在一个可以接受的范围，同时又能够提供更好的性能。</p>
<p>好了，根据以上的描述你应该大体知道了怎么存储URL了。大体思路如下所示(用md5函数举例):<br>加多一个字段 url_md5 将 md5(url) 的值存入这个字段，给 url_md5 这个字段设置唯一索引。查询的时候，将要查询的 url 取 md5: select * from table_name where url_md5=URL_MD5 and url=”url”。<br>这种方式需要注意的点就是，可能 url 不同，但是 md5(url) 相同，这种情况只需要再判断下数据表记录集里面的 url 和你需要的 url 是否相同即可。</p>
<h2 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h2><h3 id="三范式的介绍"><a href="#三范式的介绍" class="headerlink" title="三范式的介绍"></a>三范式的介绍</h3><p>范式的优点就是方便更新，只需要修改少量的信息。缺点就是需要关联，代价很高，会使一些索引策略失效。</p>
<ol>
<li><p>第一范式(<strong>确保每列保持原子性</strong>)<br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式</p>
</li>
<li><p>第二范式(<strong>消除部分子函数依赖</strong>)<br>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说<strong>在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中</strong>。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。<br>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。<br>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。<br>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可(外键关联)。</p>
</li>
<li><p>第三范式(属性不依赖于其它非主属性，<strong>消除传递依赖</strong>)<br>属性不依赖于其它非主属性.<br>假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字”学号”，因为存在如下决定关系：<br>(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)<br>这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：<br>(学号) → (所在学院) → (学院地点, 学院电话)<br>把学生关系表分为如下两个表：<br>学生：(学号, 姓名, 年龄, 所在学院)；<br>学院：(学院, 地点, 电话)。</p>
</li>
</ol>
<p>总结:<br>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。</p>
<p>第二范式：主键列与非主键列遵循完全函数依赖关系</p>
<p>第三范式：非主键列之间没有传递函数依赖关系</p>
<h3 id="为什么要反范式设计"><a href="#为什么要反范式设计" class="headerlink" title="为什么要反范式设计"></a>为什么要反范式设计</h3><p>范式化通常带来的好处：<br>范式化的更新操作通常比反范式化要快。<br>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。<br>范式化的表通常更小，可以更好地存放在内存里，所以执行操作会更快。<br>很少有多余的数据意味着检索列表数据时，更少需要 DISTINCT 或者 GROUP BY 语句。<br>范式化设计的 Schema 的缺点是通常需要关联。</p>
<p>反范式的优点：<br>反范式化的 Schema 因为所有数据都在一张表中，可以很好地避免关联。<br>单独的表也能使用更有效的索引策略。（在不关联的情况下，即使使用全表扫描，也会避免随机IO; 另外我们知道在关联的时候，索引可能会失效，所以在需要排序和过滤的场景中，设计为一个表，可以满足索引）</p>
<h3 id="如何反范式设计"><a href="#如何反范式设计" class="headerlink" title="如何反范式设计"></a>如何反范式设计</h3><p>反范式将有些数据合并，提高查询的效率，不用因为关联查询导致巨大的性能问题。</p>
<p>字段冗余：<br>比如对于经常需要查询的数据，可以通过复制的方法，存储到各个表内，加速查询的效率。比如我之前见过的activiti里面的23张表中，将流程的piid，存储了多份，就是避免了关联查询，后面的博客我会细讲。还比如用户性别这种字段，经常读取，也可以进行复制。复制的意思就是，多个表冗余存储</p>
<p>还有我们为什么要冗余呢？<br>排序的需要，如果需要通过关联的方式做排序，则代价会很高，如果将字段冗余起来，避免关联，则排序就可以利用索引加速。比如文章表，通常需要根据文章的作者名称排序，如果把作者的名称冗余到文章表，建立索引，那么就可以很好的排序了。</p>
<p>还有一种设计，就是预先计算，比如需要显示一个用户发送了多少条消息，如果每次统计的话，是一个非常昂贵的查询，如果在user发布message的时候，就更新这个值(+1)，避免了昂贵的扫描统计查询。</p>
<h3 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h3><p>汇总表的设计思想：就是将一些统计，如count的数据汇总到一张表中，比如汇总每月的统计信息，那么如果需要计算季度的信息可以将月的汇总信息加起来。<br>所以汇总表常常需要定时任务，比如要计算某个用户一天内发送了多少条消息，可以一小时生成一条汇总记录，记录该小时内发送的条数，统计的可以分为以下两种方案：</p>
<ol>
<li>粗略统计，统计过去23个小时的消息总数<br>select sum(cnt) from 汇总表 where 汇总时间 between concat(left(now(),14),”00:00”)- interval 23 hour and concat(left(now(),14),”00:00”)- interval 1 hour </li>
<li>精确统计，过去23个小时的发送总数+该小时内发送的总数<br>select count(*) from 消息表 where 发送时间 &gt; concat(left(now(),14),”00:00”)+上面sql计算的结果<br>汇总表解决的问题就是实时统计代价昂贵的问题。</li>
</ol>
<h3 id="缓存表"><a href="#缓存表" class="headerlink" title="缓存表"></a>缓存表</h3><p>缓存表的使用场景正好相反，将表中的部分列拿出来作为缓存表，如果主表使用的是innoDB引擎，那么用MYISAM作为缓存表的引擎将会得到更小的索引占用空间，并且支持fulltext索引。myisam引擎使用前缀压缩来减少索引的存储空间，而inoDB不会。缓存表的使用场景就是将部分列拿出来建立索引，满足查询排序的需求。</p>
<p>在使用缓存表和汇总表时，必须决定是实时维护数据还是定时重建。看需求。定时重建不仅节省资源，还保持表不会有很多碎片，以及完全顺序组织的索引（这会更加高效）。</p>
<pre><code class="sql"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_summary_new, my_summary_old;

<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_summary_new <span class="keyword">LIKE</span> my_summary;

<span class="comment">-- TODO：执行汇总操作</span>
<span class="keyword">RENAME</span> <span class="keyword">TABLE</span> my_summary <span class="keyword">TO</span> my_summary_old, my_summary_new <span class="keyword">TO</span> my_summary;
</code></pre>
<p>很重要的要提到的是，当我们在重建汇总表和缓存表的时候，为了保证之前汇总表或者缓存表的可用性，需要建立新表new，然后将new表命名为原来的表，将原来的表命名为old表.这样当新表数据有问题的时候，方便回滚。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangamama.github.io/hh.github.io/hh.github.io/2017/09/17/sql优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="号号(个人邮箱a981945164@163.com，不当之处请指正)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hh.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="src">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hh.github.io/2017/09/17/sql优化/" itemprop="url">Mysql的sql优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-17T22:47:52+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先胡乱的扯几句，为什么要写这个帖子呢，因为大四的时候发现自己的sql写的不太好，后来项目的网站又有性能优化的需求，就主动的断断续续的关注这个问题，下面主要对自己看到的用到的一些内容做一个总结。</p>
<h2 id="为什么查询会变慢"><a href="#为什么查询会变慢" class="headerlink" title="为什么查询会变慢"></a>为什么查询会变慢</h2><p>最简单的衡量查询开销的三个指标如下：响应时间(服务时间+排队时间(等待IO或者锁))，扫描的行数，返回的行数<br>一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏以此为：<br>在索引中使用 WHERE 条件来过滤不匹配的记录。这是在存储引擎层完成的。<br>使用索引覆盖扫描（在 Extra 列中出现了 Using index）来返回记录，直接从索引中过滤掉不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，但无须再回表查询记录。<br>从数据表中返回数据，然后过滤掉不满足条件的记录（在 Extra 列中出现 Using Where）。这在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤。   </p>
<h2 id="mysql的sql执行原理"><a href="#mysql的sql执行原理" class="headerlink" title="mysql的sql执行原理"></a>mysql的sql执行原理</h2><p><img src="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215930054-1343859589.png" alt=""><br>以上的图是mysql如何执行查询的原理图。<br><strong><em>存储引擎给查询执行引擎提供了基本的底层接口，存储引擎共有的特性则由服务器层实现，比如时间，日期，函数，视图，触发器等。  </em></strong><br>上图清楚的展示了当我们给Mysql发送一个sql查询，mysql到底做了什么事情？</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。<br>mysql如何判断缓存是否命中呢？<br>缓存存放在一个引用表中，用一个hash引用，这个哈希值包含了查询本身，客户端的协议版本，要查询的数据库等，特别要注意的是sql中，任何字符上的不同，大小写之类的，任何的不同都会导致缓存不命中。如果查询中包含任何不确定的函数，如NOW(),current_user等,MYSQL不会检查查询缓存。同样innodb的事务也会降低缓存的命中率，因为查询只有在该事务提交之后才会被缓存。<br>mysql不是通过操作系统，而是自己去管理缓存的内存空间，在初始化缓存空间的时候只会调用一次malloc()函数。当查询过来之后，首先找到一个合适的内存块(大于query_cache_min_res_unit，此时并不知道结果需要多大的内存)，等结果查询出来之后，将结果存入其中(不够用还会申请新的内存块)，之后会释放空闲内存，可能还会进行内存的合并。但是还是会出现<strong>内存碎片</strong>的问题。<br>那么到底开启还是关闭mysql的缓存？有时开启缓存反而会降低性能，此时需要关注的是Qcache_hits(缓存命中的次数):Qcache_inserts(缓存插入的次数)的比值大于3:1的时候才认为缓存有作用。对于一些很复杂的sql语句，需要很大的计算(如count()，join)，查询返回的结果比较小，是很适合做缓存的。同时开启缓存，要保证涉及的表上查询比插入更新的场景要多，对于经常更新场景，查询缓存不能带来性能的提升。<br>我个人觉得使用数据库的查询缓存是一件很复杂的事情，尤其是在有事务的情况下。更好的方案是使用应用端的缓存，而不是依赖mysql的查询缓存。</li>
<li>服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="mysql的通信协议"><a href="#mysql的通信协议" class="headerlink" title="mysql的通信协议"></a>mysql的通信协议</h3><p>Mysql服务器和客户端之前的通信采用<strong>半双工</strong>的协议，意思是好比两个人传球，球在某个时间点，只可能被一个人控制。一端发消息后，另一端完全接受到消息才能响应。一个明显的限制是，这意味着没法进行流量控制。一旦一段开始发送消息，另一段要接收完整个消息才能响应它。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。<br>多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。<br>当使用多数连接 MySQL 的库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。这里的意思是，处理 ResultSet 时，数据已经从 MySQL 服务器上读取过来数据，然后直接从 ResultSet 中取数据。<br>MySQL 连接的状态，可以理解为服务器端一个线程，该状态表示了 MySQL 当前正在做什么：<br>Sleep：线程正在等待客户端发送新的请求。<br>Query：线程正在执行查询或者正在将结果发送给客户端。<br>Locked：在 MySQL 服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如 InnoDB 的行锁，并不会体现在线程状态中。<br>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。<br>Copying to tmp table [on disk]：线程正在执行查询，并且将结果集都复制到一个临时表中，这种状态一般要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有 on disk 标记，那表示 MySQL 正在将一个内存临时表放到磁盘上。<br>Sorting result：线程正在对结果集进行排序。<br>Sending data：这表示多种情况线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p>
<h3 id="mysql的查询优化器"><a href="#mysql的查询优化器" class="headerlink" title="mysql的查询优化器"></a>mysql的查询优化器</h3><p>导致一个查询可能跟我们认为那样不一样的主要原因就是，mysql的查询优化器很复杂。<br>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数（索引中不同值的数量）、索引和数据行的长度、索引分布情况。统计信息可能不准确，还有其他原因会导致MYSQL选择错误的执行计划。<br>优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，可以认为这是一种“编译时优化”。动态优化则和查询的上下文有关，也可能和很多其他因素有关，需要在每次查询时都重新评估，可以认为是“运行时优化”。</p>
<p>查询优化器都能做什么事情呢？  </p>
<ol>
<li>优化器可以定义表关联的顺序，MYSQL查询使用循环嵌套的方式来执行查询，那么先执行大表的查找，再关联小表，循环的次数会更少。 </li>
<li>可以将外join,转化为内部join.  </li>
<li>将5=5 and a&gt;5转化为 a&gt;5, 进行等价变换</li>
<li>优化count(),Min(),MAX();索引很能帮助来进行这类统计，比如寻找最小值，只需要找到最左端的值。特别重要的是，在没有where条件的情况下，count(“*”)直接从存储引擎获取，myISAM将其作为一个变量存起来。</li>
<li>覆盖索引，无需查找对应的行</li>
<li>子查询优化</li>
<li>提前终止查询，比如limit字句。或者where id=-1,直接返回空值。</li>
<li>对in列表优化，会先对in中的列表进行排序，然后使用二分法来验证是否满足某行是否满足该in条件。</li>
</ol>
<h3 id="MySQL关联查询（个人感觉比较重要）"><a href="#MySQL关联查询（个人感觉比较重要）" class="headerlink" title="MySQL关联查询（个人感觉比较重要）"></a>MySQL关联查询（个人感觉比较重要）</h3><p>对于 UNION 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 UNION 查询。</p>
<p>MySQL 关联执行的策略：MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行位置。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL 会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL 返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。可以使用如下代码来解释：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">内关联查询 <span class="comment">----------------------------------------------------</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  tbl1.col1,</div><div class="line">  tbl2.col2</div><div class="line"><span class="keyword">FROM</span> tbl1</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span> (col3)</div><div class="line"><span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line">用伪代码来解释 MySQL 关联执行的策略则是如下：</div><div class="line">outer_iter = iterator over tbl1 WHERE col1 IN (5, 6)</div><div class="line">outer_row = outer_iter.next</div><div class="line">while outer_row</div><div class="line">    inner_iter = iterator over tbl2 WHERE col3 = outer_row.col3</div><div class="line">    inner_row  = inner_iter.next</div><div class="line">    while inner_row</div><div class="line">        output [outer_row.col1, inner_row.col2]</div><div class="line">        inner_row = inner_iter.next</div><div class="line">    <span class="keyword">end</span></div><div class="line">    outer_row = outer_iter.next</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">左外关联查询 <span class="comment">--------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  tbl1.col1,</div><div class="line">  tbl2.col2</div><div class="line"><span class="keyword">FROM</span> tbl1</div><div class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span> (col3)</div><div class="line"><span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line">用伪代码来解释 MySQL 关联执行的策略则是如下：</div><div class="line">outer_iter = iterator over tbl1 WHERE col1 IN (5, 6)</div><div class="line">outer_row = outer_iter.next</div><div class="line">while outer_row</div><div class="line">    inner_iter = iterator over tbl2 WHERE col3 = outer_row.col3</div><div class="line">    inner_row  = inner_iter.next</div><div class="line">    if inner_row</div><div class="line">        while inner_row</div><div class="line">            output [outer_row.col1, inner_row.col2]</div><div class="line">            inner_row = inner_iter.next</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">output</span> [outer_row.col1, <span class="literal">NULL</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line">    outer_row = outer_iter.next</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>那么，关联查询优化器是如何工作呢？<br>MySQL 优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。关联查询优化器通过评估不同关联顺序时的成本来选择一个代价最小的关联顺序。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  film.film_id,</div><div class="line">  film.title,</div><div class="line">  film.release_year,</div><div class="line">  actor.actor_id,</div><div class="line">  actor.first_name,</div><div class="line">  actor.last_name</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id) <span class="comment">---使用film_id来查找对应的actor_id</span></div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id) \G  <span class="comment">---使用actor_id来查找对应的记录</span></div><div class="line"></div><div class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: ALL</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></div><div class="line">      key_len: <span class="literal">NULL</span></div><div class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">rows</span>: <span class="number">200</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film_actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span></div><div class="line">possible_keys: PRIMARY,idx_fk_film_id</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.actor.actor_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">27</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></div><div class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: eq_ref</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film_actor.film_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">1</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p>
<p>从这个执行计划就能能看出这个查询是从 actor 开始查询的。对比一下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span></div><div class="line">  film.film_id,</div><div class="line">  film.title,</div><div class="line">  film.release_year,</div><div class="line">  actor.actor_id,</div><div class="line">  actor.first_name,</div><div class="line">  actor.last_name</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id)</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id) \G</div><div class="line"></div><div class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: ALL</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></div><div class="line">      key_len: <span class="literal">NULL</span></div><div class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">rows</span>: <span class="number">1000</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film_actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span></div><div class="line">possible_keys: PRIMARY,idx_fk_film_id</div><div class="line">          <span class="keyword">key</span>: idx_fk_film_id</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film.film_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">5</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></div><div class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: eq_ref</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film_actor.actor_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">1</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div></pre></td></tr></table></figure></p>
<p>在这里我们发现STRAIGHT_JOIN之后，将不会使用优化器进行优化，此时的关联顺序与优化后的是相反的，为什么是相反的呢？</p>
<ol>
<li>将film作为第一个表的时候，会找到950条记录，意思是最外层的循环是950次—（1次查询+950次查询）</li>
<li>将actor作为第一个表的时候，最外层的循环是200次—（1次查询+200次查询）</li>
</ol>
<p><strong>当我们被问到两个表关联的时候，那个做主表？</strong><br>答案是：小表做主表，例如a表1条记录，b表10000条记录，连接条件是a.id = b.id,先从a表找就只需要确定b表中有无满足条件的记录，1次就ok,如果先从b表找，就需要找10000次<br>同时还要告诉他：数据库优化引擎会在解析阶段根据索引和统计信息选择合理的执行计划。</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>如果需要排序的数量小于“排序缓冲区”，MySQL 使用内存进行“快速排序”操作。如果内存不够排序，那么 MySQL 会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并merge排序，最后返回排序结果。</p>
<p>还有排序涉及到的一次扫描算法和两次扫描算法，见上一个博客(mysql索引)</p>
<h2 id="各个sql优化场景"><a href="#各个sql优化场景" class="headerlink" title="各个sql优化场景"></a>各个sql优化场景</h2><p><strong>应用与数据库： 数据库擅长于计数，而应用层适合字符串的处理和正则</strong></p>
<h3 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 原始写法</span></div><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (</div><div class="line">  <span class="keyword">SELECT</span> film_id</div><div class="line">  <span class="keyword">FROM</span> film_actor</div><div class="line">  <span class="keyword">WHERE</span> actor_id = <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 改进后的写法</span></div><div class="line"><span class="keyword">SELECT</span> film.*</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id)</div><div class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>原始查询为什么慢？<br>首先原始的查询会改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</div><div class="line">    <span class="keyword">SELECT</span> *</div><div class="line">    <span class="keyword">FROM</span> film_actor</div><div class="line">    <span class="keyword">WHERE</span> actor_id = <span class="number">1</span></div><div class="line">          <span class="keyword">AND</span> film_actor.film_id = film.film_id);</div></pre></td></tr></table></figure>
<p>这是一个相关子查询，如果外层的表film很大，性能将会很差。</p>
<p><em>子查询分为两类：<br>非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询。<br>相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次。</em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> t1.ename,t1.job,t1.sal <span class="keyword">from</span> emp t1  </div><div class="line"><span class="keyword">where</span> t1.sal &gt; (  </div><div class="line">  <span class="keyword">select</span> <span class="keyword">avg</span>(t2.sal) <span class="keyword">from</span> emp t2 <span class="comment">--子查询是一个独立的查询  </span></div><div class="line">);  </div><div class="line"><span class="keyword">select</span> t1.ename,t1.job,t1.sal <span class="keyword">from</span> emp t1  </div><div class="line"><span class="keyword">where</span> t1.sal &gt; (  </div><div class="line">  <span class="keyword">select</span> <span class="keyword">avg</span>(t2.sal) <span class="keyword">from</span> emp t2  </div><div class="line">  <span class="keyword">where</span> t2.deptno=t1.deptno  <span class="comment">--依赖于外部查询结果  </span></div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id)</div><div class="line"><span class="keyword">FROM</span> actor</div><div class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span></div><div class="line"></div><div class="line"><span class="keyword">id</span>, select_type, <span class="keyword">table</span>, <span class="keyword">partitions</span>, <span class="keyword">type</span>, possible_keys, <span class="keyword">key</span>, key_len, <span class="keyword">ref</span>, <span class="keyword">rows</span>, filtered, Extra</div><div class="line"><span class="string">'1'</span>, <span class="string">'SIMPLE'</span>, <span class="string">'actor'</span>, <span class="literal">NULL</span>, <span class="string">'ALL'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">'200'</span>, <span class="string">'100.00'</span>, <span class="string">'Using where'</span></div></pre></td></tr></table></figure>
<p>因为first_name并没有索引，如上所示将会全表扫描(type:all),但是实际上我们已经知道使用主键扫描，当 MySQL 读到第一个满足条件的记录的时候，就是我们需要的最小值了。所以以上的sql可以被改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> actor_id</div><div class="line"><span class="keyword">FROM</span> actor</div><div class="line"><span class="keyword">USE</span> <span class="keyword">INDEX</span> (PRIMARY)</div><div class="line"><span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span></div><div class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>一个容易产生的误解：MyISAM 的 COUNT() 函数总是非常快，不过这是有前提条件的，即只有没有任何 WHERE 条件的 COUNT(<em>) 才非常快。MySQL 利用存储引擎的特性直接获取这个值。<br>如果 MySQL 知道某个列 col 不可能为 NULL 值，那么 MySQL 内部会将 COUNT(col) 表达式转化为 COUNT(</em>)。<br>虽然上面的查询type依然是ALL，但是可以减少扫描行数。<br>一个优化的例子如下所示:</p>
<pre><code class="sql">没有优化的 SQL，需要扫描大多数行
<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)
<span class="keyword">FROM</span> city
<span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">5</span>;

优化后的 SQL，只需要扫描少量的行,这里可以优化的原因是<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> city在查询优化器中会被转化为常量处理
<span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)
        <span class="keyword">FROM</span> city) - <span class="keyword">COUNT</span>(*)
<span class="keyword">FROM</span> city
<span class="keyword">WHERE</span> <span class="keyword">id</span> &lt;= <span class="number">5</span>;

如何在一个sql查询不同颜色的数量,不满足条件的设置为null就OK了
<span class="keyword">SELECT</span>
  <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue,
  <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>)  <span class="keyword">AS</span> red
<span class="keyword">FROM</span> items;
</code></pre>
<h3 id="关联的时候如何建立索引"><a href="#关联的时候如何建立索引" class="headerlink" title="关联的时候如何建立索引"></a>关联的时候如何建立索引</h3><p>  确保 ON 或者 USING 子句的列上有索引。当A，B两个表用c做关联的时候，如果优化器的关联顺序是B(B是小表)，A，那么只需要在A表上的c列上建立索引。</p>
<h3 id="优化-GROUP-BY-和-DISTINCT"><a href="#优化-GROUP-BY-和-DISTINCT" class="headerlink" title="优化 GROUP BY 和 DISTINCT"></a>优化 GROUP BY 和 DISTINCT</h3><p>在 MySQL 中，当无法使用索引的时候， GROUP BY 使用两种策略来完成：使用临时表或者文件排序来分组。<br>一个优化的例子如下所示：</p>
<pre><code class="sql">这个查询效率不会很好
<span class="keyword">SELECT</span>
  actor.first_name,
  actor.last_name,
  <span class="keyword">COUNT</span>(*)
<span class="keyword">FROM</span> film_actor
  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)
<span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name, actor.last_name;
//这个查询的效率更高，如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效果会比其他列更高
<span class="keyword">SELECT</span>
  actor.first_name,
  actor.last_name,
  <span class="keyword">COUNT</span>(*)
<span class="keyword">FROM</span> film_actor
  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)
<span class="keyword">GROUP</span> <span class="keyword">BY</span> film_actor.actor_id;
</code></pre>
<h3 id="使用用户自定义变量的场景"><a href="#使用用户自定义变量的场景" class="headerlink" title="使用用户自定义变量的场景"></a>使用用户自定义变量的场景</h3><p>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信。<br>使用用户自定义变量的一个重要特性是可以在给一个变量赋值的同时使用这个变量。</p>
<pre><code class="sql">使用变量显示行号
<span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;
<span class="keyword">SELECT</span>
  actor_id,
  @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">rownum</span>
<span class="keyword">FROM</span> actor
<span class="keyword">LIMIT</span> <span class="number">3</span>;
下面的例子是找出电影数量最多的10个演员，要求是当电影数量一样的时候，排名一样。
<span class="keyword">SET</span> @curr_cnt := <span class="number">0</span>, @prev_cnt := <span class="number">0</span>, @<span class="keyword">rank</span> := <span class="number">0</span>;

<span class="keyword">SELECT</span>
  actor_id,
  @curr_cnt := cnt                                          <span class="keyword">AS</span> cnt,//当前这个演员的电影数量
  @<span class="keyword">rank</span>     := <span class="keyword">if</span>(@prev_cnt &lt;&gt; @curr_cnt, @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span>) <span class="keyword">AS</span> <span class="keyword">rank</span>,//当前这个演员的电影数量与上一个排名的电影数量不一样的时候，<span class="keyword">rank</span>才加<span class="number">1</span>
  @prev_cnt := @curr_cnt                                    <span class="keyword">AS</span> dummy
<span class="keyword">FROM</span> (
   <span class="keyword">SELECT</span>
     actor_id,
     <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt
   <span class="keyword">FROM</span> film_actor
   <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id
   <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span>
   <span class="keyword">LIMIT</span> <span class="number">10</span>
) <span class="keyword">AS</span> der;

更新行的同时返回行的信息，相当于java里面的addAndGet()
 常规做法
<span class="keyword">UPDATE</span> tbl <span class="keyword">SET</span> tbl.lastupdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;
<span class="keyword">SELECT</span> lastupdated <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;
 使用变量，无须访问数据表，更高效
<span class="keyword">UPDATE</span> tbl <span class="keyword">SET</span> tbl.lastupdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">now</span> := <span class="keyword">NOW</span>();
<span class="keyword">SELECT</span> @<span class="keyword">now</span>;

将用户分为热门用户和归档用户。查询用户时，热门用户中查不出来才去查归档用户，避免不必要的 UNION 子查询。
查询用户，热门用户中查不出来则查归档用户
<span class="keyword">SELECT</span>
  <span class="keyword">greatest</span>(@<span class="keyword">found</span> := <span class="number">-1</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span>,//<span class="keyword">GREATEST</span>()函数返回输入参数(n1, n2, n3, 等)组的最大值
  <span class="string">'users'</span>                    <span class="keyword">AS</span> which_tbl
<span class="keyword">FROM</span> <span class="keyword">users</span>
<span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>

<span class="keyword">UNION</span> ALL

<span class="keyword">SELECT</span>
  <span class="keyword">id</span>,
  <span class="string">'users_archived'</span> <span class="keyword">AS</span> which_tbl
<span class="keyword">FROM</span> users_archived
<span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">found</span> <span class="keyword">IS</span> <span class="literal">NULL</span>

<span class="keyword">UNION</span> ALL
将变量充值，避免影响下次查询
<span class="keyword">SELECT</span>
  <span class="number">1</span>,
  <span class="string">'reset'</span>
<span class="keyword">FROM</span> dual <span class="comment">---dual虚拟表</span>
<span class="keyword">WHERE</span> (@<span class="keyword">found</span> := <span class="literal">NULL</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;
</code></pre>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>当使用group by的时候，结果会自动根据分组的字段进行排序，如果不在乎顺序，而这种默认的排序使用的文件排序，那么使用order by null.也可以直接在group by后面加acs,desc</li>
<li>如果需要重复使用大型表中的某个数据集，那么建立临时表是很好的选择，如果使用到了临时表，需要显示的删除先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>对select *保持怀疑态度，大部分情况下，这种查询都是错误的。  </li>
<li>使用union all代替or,一般情况下一定要使用union all,这样会避免在临时表中去重复，会极大的提高性能。  </li>
<li>Like很慢，有必要的话使用fulltext全文索引</li>
<li>确保group和order by中的表达式只涉及一个表的列</li>
<li><p>关于分页的优化，在上一节讲过，就是利用延迟关联的思想，要解决的问题就是当偏移量特别大的时候，扫描的性能很差，可以使用索引覆盖扫描，让查询更快</p>
<pre><code class="sql">延迟关联，大大提升查询效率
<span class="keyword">SELECT</span>
  film_id,
  description
<span class="keyword">FROM</span> film
  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (
       <span class="keyword">SELECT</span> film_id
       <span class="keyword">FROM</span> film
       <span class="keyword">ORDER</span> <span class="keyword">BY</span> title
       <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">5</span>
     ) <span class="keyword">AS</span> lim <span class="keyword">USING</span> (film_id);
</code></pre>
</li>
<li><p>将查询分解，将查询分解后，执行单个查询可以减少锁的竞争。在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。可以减少冗余记录的查询。这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。某些场景哈希关联的效率要高很多,让应用层做更多的事，或者更擅长的事，也是一个很好的策略。将某些逻辑处理交给应用层处理也很有帮助。</p>
</li>
<li><strong>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>非常主要的一点：<br>count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinct<br>col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li>
<li>当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为<br>NULL，因此使用 sum()时需注意 NPE 问题。<br>正例： 可以使用如下方式来避免 sum 的 NPE 问题： SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM<br>table;</li>
<li>【强制】使用 ISNULL()来判断是否为 NULL 值。注意： NULL 与任何值的直接比较都为 NULL。<br>说明：<br>1） NULL&lt;&gt;NULL 的返回结果是 NULL，不是 false。<br>2） NULL=NULL 的返回结果是 NULL，不是 true。<br>3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</li>
</ol>
<h3 id="范围查询如何使用索引"><a href="#范围查询如何使用索引" class="headerlink" title="范围查询如何使用索引"></a>范围查询如何使用索引</h3><p>这里有个很重要的技巧就是<strong>使用in来满足索引的最左匹配</strong>，当我们使用某个索引进行范围的查询那么，其后续的索引就无法用来做排序了，此时就会使用filesort。如何避免这种情况呢？<br>就是通过in来满足最多前缀，比如现在有索引(sex,age),我们希望对age排序，可以使用where sex in(‘m’,’f’) order by age。为什么age建立了索引，因为基本的查询都会查询性别，所以sex 虽然选择性不高，作为索引，可以满足覆盖索引。这跟我们前面讲到的有冲突。这里强调的是通过in()可以满足最左前缀。但是不能滥用，如果In里面的列表太大，就会有性能问题。</p>
<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>但是很多优化的策略并不是绝对的，我觉得需要用explain进行分析。<br>type:<br>表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:<br>ALL, index,  range, ref, eq_ref, const, system, NULL从左到右，性能从最差到最好<br>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行<br>index：Full Index Scan，index与ALL区别为index类型只遍历索引树<br>range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有&lt;, &gt;查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。<br>ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行<br>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件<br>const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量<br>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<p>Extra:包含不适合在其他列中显示但十分重要的额外信息<br>Using index:该值表示相应的select操作中使用了覆盖索引（Covering Index）<br>Using where:<br>表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示”Using where”。有时”Using where”的出现就是一个暗示：查询可受益于不同的索引。<br>Using temporary：<br>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询<br>Using filesort：<br>MySQL中无法利用索引完成的排序操作称为“文件排序”<br>Using join buffer：<br>强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>很容易把 Extra 列的 “Using index” 和 type 列的 “index” 搞混淆。其实这两者完全不同， type 列和覆盖索引毫无关系；它只是表示这个查询访问数据的方式，或者说是 MySQL 查找行的方式。 MySQL 手册中称之为连接方式（join type）<br>取最大值或者最小值时，如果有索引，则可以直接从 B-Tree 索引的两端取数据，在 EXPLAIN 中就可以看到 Select tables optimized away。从字面意思可以看出，它表示优化器已经从执行计划中移除了该表，并以一个常数取而代之</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>如果你能清晰的看出下面几道题是否能使用索引，那么索引的知识就基本掌握了：</p>
<p>索引(user_id,msg_id)<br>ordey by user_id             Yes<br>ordey by user_id,msg_id      Yes<br>user_id=5 ordey by msg_id      Yes<br>user_id&gt;5 ordey by msg_id      部分<br>user_id&gt;5 ordey by user_id，msg_id      YES<br>ordey by msg_id            No<br>ordey by user_id desc ,msg_id  asc 部分</p>
<p>user_id=5            yes<br>user_id between 5 and 10   yes<br>user_id=5 and msg_id between 5 and 10   yes<br>user_id=5 between 5 and 10 and msg_id=5   部分<br>user_id In(5,6,7) and msg_id=5  yes————-<strong>这个就是我提到的用in来满足最左前缀的策略，相当有用</strong><br>msg_id=5       No<br>user_id=5 and msg_id&gt;5  and msg=”hello”   部分</p>
<p><strong>[美团团队写的慢sql的案例(可以参考)]</strong>(<a href="https://tech.meituan.com/mysql-index.html](https://tech.meituan.com/mysql-index.html" target="_blank" rel="external">https://tech.meituan.com/mysql-index.html](https://tech.meituan.com/mysql-index.html</a>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangamama.github.io/hh.github.io/hh.github.io/2017/09/13/谈谈Mysql的索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="号号(个人邮箱a981945164@163.com，不当之处请指正)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hh.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="src">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hh.github.io/2017/09/13/谈谈Mysql的索引/" itemprop="url">谈谈Mysql的索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T21:28:47+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机中的存储介质与局部性原理"><a href="#计算机中的存储介质与局部性原理" class="headerlink" title="计算机中的存储介质与局部性原理"></a>计算机中的存储介质与局部性原理</h2><p>计算机中最重要的存储介质分为几类：硬盘、内存、二级缓存(L3,L2，L1)、寄存器。从左往右，访问速度从慢到快，制造成本也越来越高。</p>
<p><em>什么是随机IO和顺序IO?<br>随机访问的特点是每次IO请求的数据在磁盘上的位置跨度很大（如：分布在不同的扇区），因此N个非常小的IO请求（如：1K），必须以N次IO请求才能获取到相应的数据。<br>顺序访问的特点跟随机访问相反，它请求的数据在磁盘的位置是连续的。当系统发起N个非常小的IO请求（如：1K）时，因为一次IO是有代价的，系统会取完整的一块数据（如4K、8K），所以当第一次IO完成时，后续IO请求的数据可能已经有了。这样可以减少IO请求的次数。这也就是所谓的预取。</em><br>机械硬盘的磁头移动至正确的磁道上需要时间，随机读写时，磁头不停的移动，时间都花在了磁头寻道上，导致的就是性能不高。所以，对于机械硬盘来说，连续读写性很好，但随机读写性能很差。</p>
<p>由于存储介质的特性，硬盘本身存取就比主存慢很多，再加上机械运动耗费，硬盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。磁盘往往也不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<br>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<h2 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h2><p>创建好的索引对应用来说特别重要，因为随机IO访问特别慢，如果服务器从存储中读取一个数据块，就为了其中的一行数据那么，那么访问会超级慢。使用索引引用访问的行，那么效率将会提升很多。如果数据存放在机械硬盘，那么速度会更慢。  总结起来有下列优点： </p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量，</li>
<li>并且能够避免临时表，</li>
<li>索引能够将随机IO变为顺序IO。</li>
</ul>
<p>MYSQL支持很多索引，但是最核心的是B+tree索引。索引的本质就是数据结构。</p>
<h2 id="MYISAM索引与innodb索引"><a href="#MYISAM索引与innodb索引" class="headerlink" title="MYISAM索引与innodb索引"></a>MYISAM索引与innodb索引</h2><h3 id="MYISAM索引"><a href="#MYISAM索引" class="headerlink" title="MYISAM索引"></a>MYISAM索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：<br><img src="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215534429-38509930.png" alt=""><br>这里设表一共有三列，假设我们以Col1为主键，则图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和二级索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<h3 id="innodb索引"><a href="#innodb索引" class="headerlink" title="innodb索引"></a>innodb索引</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。<br>第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录，而节点页只包括了索引列。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。  如下图所示:<br><img src="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215617179-1361223178.png" alt=""></p>
<p>为什么不推荐使用uuid做主键？<br>因为主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录都会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。<br>对于无序的主键，所以 InnoDB 无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置，通常是已有数据的中间位置，并且分开空间。这会增加很多额外的工作，并导致数据分布不够优化。导致的主要缺点就是<strong>页分裂</strong>，由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片，InnoDB 在随机插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机 I/O。<br>所以说InnoDB聚集索引，严重依赖插入的顺序，聚集索引的更新代价会很大，因为InnoDB会将每个被更新的行移动到新的位置。</p>
<h3 id="MYISAM与innodb的区别"><a href="#MYISAM与innodb的区别" class="headerlink" title="MYISAM与innodb的区别"></a>MYISAM与innodb的区别</h3><ol>
<li>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</li>
<li>第二个与MyISAM索引的不同是InnoDB的二级索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有二级索引都引用主键作为data域。使用主键作为指针会让二级索引占用更多的空间，但是换来的好处就是移动行时或者数据的页分裂的时候， 无需更新二级索引中的这个指针(即主键)，这样就简化了行移动时二级索引的维护。</li>
<li>InnoDB聚集索引包含了主键，还有其他的列，事务ID，而MYISAM 的聚集索引，存储的保存数据的地址(有时为行号)。<br><strong>简单的说，InnoDB聚集索引可以理解为表本身。</strong></li>
<li>MYISAM引擎，采用了前缀压缩的技术更加节省空间，但是压缩之后，会影响查找的性能(后面的依赖前面的进行压缩)。Innodb不会压缩。<br>比如索引块中第一个值为perform,第二个performance,那么第二个压缩后的形式为7,ance,这种压缩的好处就是减少了索引的大小，但是使某些查询会变慢，正序的扫描没有问题，但是无法使用二分查找。利用order by ..desc倒序的很慢了。<br>在create table pack_keys中可以指定压缩的方式。<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3></li>
</ol>
<p>从以上可知，聚簇索引代表了数据存储的方式，那么一张表只能有一个聚簇索引，其主键作为聚簇索引的索引列。就是按照主键ID来聚集数据。<br>覆盖索引是什么呢？<br>如果一个索引包含了需要查询的字段的值，不用再回表查询，称之为“覆盖索引”，或者也叫二级索引。二级索引可以有多个。覆盖索引能极大的提高查询的性能，表现在一下几个方面：</p>
<ol>
<li>索引更小，能够放到内存中，对IO密集型的应用特别用帮助，如果一个查询只需要读取索引，会极大的减少数据的访问量。<br><em>什么是IO密集，ＣＰＵ密集？<br>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。<br>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</em></li>
<li>索引本身是按照顺序存储的，所以对ＩＯ密集型应用，比随机io要快很多。</li>
<li><strong>这一个点非常重要，就是InnoDB的覆盖索引在叶子节点的data域中保存了主键值，所以主键肯定是覆盖查询的，利用这一个点，可以做延迟关联的查询，我后面会详细分析</strong></li>
</ol>
<h3 id="MYISAM与innodb的使用场景是什么？"><a href="#MYISAM与innodb的使用场景是什么？" class="headerlink" title="MYISAM与innodb的使用场景是什么？"></a>MYISAM与innodb的使用场景是什么？</h3><p>以上从索引的角度，谈了MYISAM与innodb的索引区别。<br>我觉得MYISAM能够得到更好的性能，对于读多写少更新少的场景，优先选择MYISAM。而对于事务，外键，行级锁有要求，可以采用innodb，但是这里有个坑，innodb并不是任何时候都可以使用行级锁，只有通过索引条件检索数据，innoDB才使用行级锁，否则InnoDB将使用表锁。其他的细节上的区别如下所示：</p>
<ol>
<li>InnoDB不支持FULLTEXT类型的索引。</li>
<li>InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</li>
<li>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</li>
<li>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表</li>
<li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引</li>
</ol>
<h2 id="如何建立索引"><a href="#如何建立索引" class="headerlink" title="如何建立索引"></a>如何建立索引</h2><p>我们要思考的问题是，那些列适合做索引，当有多列索引时，如何选择索引的顺序？</p>
<ol>
<li><p>text或者很长的varchar，必须使用前缀索引。因为mysql不允许这些列的完整长度<br>那么，这个前缀索引的长度如何选择呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="keyword">value</span>,<span class="number">3</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> p3,</div><div class="line">       <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="keyword">value</span>,<span class="number">4</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> p4,</div><div class="line">       <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="keyword">value</span>,<span class="number">5</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> p5,</div><div class="line"><span class="keyword">from</span> table1</div></pre></td></tr></table></figure>
<p>因为varchar这样的，要满足最左前缀，所以只有like “abc%”才会使用到索引，而like “%bac%”是不会用到索引的，很多网上的帖子在这个点上都是忽悠人的。<br>观察当长度选择某个值之后，计算出的选择性提升比较缓慢的时候，就选择该长度。</p>
</li>
<li>索引的选择性=不重复的索引值的行数/表的总行数，索引的选择性越高，越适合建立索引（但是也有例外，下面会提到）。主键索引的选择性就是1，例如用性别做索引就不太好，因为选择性很低，只有男女两种值。</li>
<li><strong>选择合适的索引列顺序</strong>：<br>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。<br>这里有一个注明的“三星索引”的评价标准：<ul>
<li>　索引将相关的记录放到一起则获得一星；</li>
<li>　如果索引中的数据顺序和查找中的排列顺序一致则获得二星；</li>
<li>　如果索引中的列包含了查询中需要的全部列则获得“三星”。—&gt;达到了覆盖索引的目标<br>　<strong>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。通常不如避免随机 IO 和排序那么重要。</strong>意思是索引对查询的核心的提升是为了覆盖索引，避免再回表去做随机IO的查询，还有在排序时生成临时表。因为索引本身是有序的，能正确的使用索引的话，可以避免临时表。<br>当不需要考虑排序和分组时，将选择性最高的列放到索引最前列通常是很好的(也有例外)。<br>虽然索引的顺序是按照选择性进行设计的，但是有些特例，有些具体的值分布很诡异，导致索引的查询特别慢，比如特定的值，匹配了大量的行数，会导致索引的选择性很差，对于这些问题，需要特例分析。</li>
</ul>
</li>
</ol>
<h3 id="覆盖索引的延时关联策略"><a href="#覆盖索引的延时关联策略" class="headerlink" title="覆盖索引的延时关联策略"></a>覆盖索引的延时关联策略</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></div><div class="line"> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">'%APOLLO%'</span>;</div></pre></td></tr></table></figure>
<p>这里索引无法覆盖该查询，有两个原因：<br>没有任何索引能够覆盖这个查询。查询从表中选择了所有的行，而没有任何索引覆盖了所有的列。<br>MySQL 不能在索引中执行 LIKE 操作。这是底层存储引擎 API 的限制。MySQL 能在索引中做最左前缀匹配的 LIKE 比较。<br>可以重新查询并巧妙地设计索引，先将索引扩展至覆盖三个数据列（actor、title、prod_id），然后如下方式重写查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line">  <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> prod_id</div><div class="line">        <span class="keyword">FROM</span> products</div><div class="line">        <span class="keyword">WHERE</span> actor = <span class="string">'SEAN CARREY'</span></div><div class="line">              <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">'%APOLLO%'</span>) <span class="keyword">AS</span> t1</div><div class="line">    <span class="keyword">ON</span> t1.prod_id = products.prod_id;</div></pre></td></tr></table></figure></p>
<p>这种方式叫做延迟关联，因为延迟了对列的访问。在查询的第一阶段 MySQL 可以使用覆盖索引，在 FROM 子句的子查询中找到匹配的 prod_id，然后根据这些 prod_id 值在外层查询匹配获取需要的所有列值。<br>这种优化方式在数据量很大，符合条件的数据很小时，优化效果明显；所以这种策略，常常被用作分页的场景：</p>
<p>普通limit M，N的翻页写法，往往在越往后翻页的过程中速度越慢，原因 mysql会读取表中的前M+N条数据，M越大，性能就越差：<br> select  *  from t where sellerid=100 limit 100000，20 优化写法：  </p>
<pre><code class="sql"><span class="keyword">select</span> t1.* <span class="keyword">from</span>  t t1, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t  sellerid=<span class="number">100</span> <span class="keyword">limit</span> <span class="number">100000</span>，<span class="number">20</span>) t2 <span class="keyword">where</span> t1.id=t2.id;
</code></pre>
<p> 优化后的翻页写法，先查询翻页中需要的N条数据的主键id，在根据主键id回表查询所需要的N条数据，此过程中查询N条数据的主键ID在索引中完成。<br> 这种优化的根本出发点，是减少在数据页中的扫描量。覆盖索引出发点就是直接从二级索引中直接获取查询结果。 </p>
<h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>MySQL 可以使用同一个索引既满足排序，又用于查找行。设计索引时应该尽可能地同时满足这两种任务。<br>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时， MySQL 才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。 ORDER BY 子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则， MySQL 都需要执行排序操作，而无法利用索引排序。<br>如果无法满足最左前缀，有一个策略就是指定常量进行弥补。<br>当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果（实际上就是外排序，使用临时表）<br>对于filesort，MySQL有两种排序算法。<br>(1)两次扫描算法(Two passes)<br>实现方式是先将需要排序的字段和可以直接定位到相关行数据的指针信息取出，然后在设定的内存（通过参数sort_buffer_size设定）中进行排序，完成排序之后再次通过行指针信息取出所需的Columns。<br>注：该算法是4.1之前采用的算法，它需要两次访问数据，尤其是第二次读取操作会导致大量的随机I/O操作。另一方面，内存开销较小。</p>
<p>(2)一次扫描算法(single pass)<br>该算法一次性将所需的Columns全部取出，在内存中排序后直接将结果输出。<br>注：从 MySQL 4.1 版本开始使用该算法。它减少了I/O的次数，效率较高，但是内存开销也较大。如果我们将并不需要的Columns也取出来，就会极大地浪费排序过程所需要的内存。在 MySQL 4.1 之后的版本中，可以通过设置 max_length_for_sort_data 参数来控制 MySQL 选择第一种排序算法还是第二种。当取出的所有大字段总大小大于 max_length_for_sort_data 的设置时，MySQL 就会选择使用第一种排序算法，反之，则会选择第二种。为了尽可能地提高排序性能，我们自然更希望使用第二种排序算法，所以在 Query 中仅仅取出需要的 Columns 是非常有必要的。</p>
<p>什么是sql的最左前缀？<br>比如在mysql中的Sakila表中，有索引(rental_date,inid,cusid),当然二级索引自动覆盖主键key，这里是rid</p>
<pre><code class="sql"><span class="keyword">select</span> rid,cusid <span class="keyword">from</span>  Sakila <span class="keyword">where</span> rental_date=<span class="string">'2017-2-1'</span> <span class="keyword">order</span> <span class="keyword">by</span> inid, cusid;
</code></pre>
<p>上面的查询满足最左前缀，使用索引排序。<br>以下的查询也满足最左前缀：<br> where rental_date=’2017-2-1’ order by inid<br> where rental_date&gt;’2017-2-1’ order by rental_date,inid<br>以下的查询不满足最左前缀：<br>where rental_date=’2017-2-1’ order by inid asc , cusid desc;<br>where rental_date=’2017-2-1’ order by inid  , rid;<br>where rental_date=’2017-2-1’ order by cusid;<br>where rental_date&gt;’2017-2-1’ order by inid,cusid//第一列使用的是范围查询，所以无法使用索引的其他列<br>where rental_date=’2017-2-1’ and inid in(1,2) order by cusid//对于排序来说，inid也是范围查询。与上类似</p>
<h3 id="冗余索引和重复索引"><a href="#冗余索引和重复索引" class="headerlink" title="冗余索引和重复索引"></a>冗余索引和重复索引</h3><p>如果创建了索引（A，B），再创建索引（A）就是冗余索引。还有一种情况是将一个索引扩展为（A，ID），其中 ID 是主键，对于 InnoDB 来说主键列已经包含在二级索引中，这也是冗余。<br>重复索引指在相同的列上按照相同的顺序创建的相同类型的索引。遇到这种索引，应该立马删除。但有时处于性能的考虑需要冗余，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。<br>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引，完全是累赘，建议考虑删除。</p>
<h3 id="锁与索引"><a href="#锁与索引" class="headerlink" title="锁与索引"></a>锁与索引</h3><p>上面提到在没使用索引的情况下，会锁住整个表。同时，要记住，索引使用不当的话，同样会锁住比我们想象的更多的行数。例子如下：<br>select id from table where id&lt;5 and id!=1 for update;//实际上锁住了1–4的所有记录，而不是2,3,4的记录.<br>InnoDB 在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。</p>
<h3 id="表的碎片优化"><a href="#表的碎片优化" class="headerlink" title="表的碎片优化"></a>表的碎片优化</h3><p>如果b tree的叶子页在物理上不是顺序且紧密的，对范围查询，索引覆盖扫描等操作来说会有很大的性能损失，常见的表的碎片有三种<br>行碎片（Row fragementation）<br>指的是数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。</p>
<p>行间碎片（Intra-row fragementation）<br>指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。对全表扫描或聚簇索引扫描之类的操作有很大的影响。</p>
<p>剩余空间碎片（Free space fragementation）<br>数据页中有大量的空余空间。会导致服务器读取大量不需要的数据，从而造成浪费。<br>对于 MyISAM 表，这三类碎片化都可能发生。但 InnoDB 不会出现短小的行碎片；InnoDB 会移动短小的行并重写到一个片段中。<br>OPTIMIZE TABLE 或者导出再导入的方式重新整理数据，消除碎片。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>尽量避免随机io<br>覆盖查询很快<br>使用索引，避免order by与group的临时表</p>
<h2 id="附录-B树、B-树"><a href="#附录-B树、B-树" class="headerlink" title="附录 B树、B+树"></a>附录 B树、B+树</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树与红黑树类似，但在降低磁盘I/O操作次数方面要更好一些，B树的结点可以有许多子女，从几个到几千个不等，一个B树结点可以拥有的子女数是由磁盘页的大小所决定，这是因为一个结点的大小通常相当于一个完整的磁盘页。磁盘存取次数是按需要从盘中读出或向盘中写入的信息的页数来度量的，所以，存取磁盘的总时间可以近似为读或写的页数。因此，B树一般都选择大的分支因子，这样可以大大降低树的高度，以及寻找任意关键字所需的磁盘存取次数。一棵分支因子为1001， 高度为2的B树，可以储存超过10亿个关键字，同时因为根节点可以持久地保留在内存中，故在这棵树中，寻找一个关键字至多只需要两次磁盘存取。如下图所示：<br>这里说的磁盘页也可以成为磁盘块，，一般块的大小在1k~4k左右<br><img src="http://hi.csdn.net/attachment/201106/7/8394323_130745821166Sc.jpg" alt=""><br>用阶来定义B树，m阶：<br>叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素<br>树中每个结点最多含有m个孩子（m&gt;=2）<br>内部节点有x个关键字数，那么有x+1个指针。其中X个关键字是升序排列的。每个叶节点具有相同的深度。一颗m阶的B树，每个内部节点的关键字个数n,必须小于m-1,大于ceil(m/2)-1(根节点除外)。<br>根节点至少有2棵子树。</p>
<p>还有一种B树的定义方法叫做度：<br>最小度数即内节点中节点最小孩子数目（m&gt;=2）<br>每个非根的结点必须至少含有m-1个关键字，m个孩子，如果树是非空的，则根结点至少包含一个关键字<br>每个结点可包含至多2m-1个关键字，所以一个内结点至多可有2m个子女。</p>
<h4 id="B树高度"><a href="#B树高度" class="headerlink" title="B树高度"></a>B树高度</h4><p>以下证明来自算法导论：<br><img src="http://img.my.csdn.net/uploads/201209/27/1348727095_3238.jpg" alt=""></p>
<h4 id="B树插入-面试很有可能被问到"><a href="#B树插入-面试很有可能被问到" class="headerlink" title="B树插入(面试很有可能被问到)"></a>B树插入(面试很有可能被问到)</h4><p>下面以一个5阶B树为例子，即key的个数为(2–4),指针(3–5)<br>关键思路如下所示：<br>对高度为h的m阶B树，新节点一般都是插入在第h层，通过检索就可以确定插入的位置，然后分以下两种情况进行讨论：</p>
<ol>
<li>若该节点的关键字个数少于m-1, 则直接插入</li>
<li>若关键字的个数=m-1, 就要节点分裂，以中间的关键字将节点一分为二，产生一个新的节点，并把中间的关键字插入到父节点h-1层。<br>重复上述步骤，最坏的情况就是一直分裂到根节点，然后建立一个新的根节点，B树的高度增加一层。<br>如下所示我们将C N G A H E K Q M F W L T Z D P R X Y S插入到5阶树中，前面几个C N G A H E K Q M F W L T的步骤省略<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525895Gzrw.jpg" alt=""><br>插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_13075258952zo1.jpg" alt=""><br>插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525895q8j1.jpg" alt=""><br>最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525894XPqO.jpg" alt=""><h4 id="B树删除-面试很有可能被问到"><a href="#B树删除-面试很有可能被问到" class="headerlink" title="B树删除(面试很有可能被问到)"></a>B树删除(面试很有可能被问到)</h4></li>
</ol>
<p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。<br>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。</p>
<ol>
<li>首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525891j1B1.jpg" alt=""></li>
<li>删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525890gB3b.jpg" alt=""></li>
<li>下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525887QhC3.jpg" alt=""></li>
<li>最后一步删除E， 删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525886x2r2.jpg" alt=""><br>其实，还没结束，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=&lt;n&lt;=4，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="http://hi.csdn.net/attachment/201106/8/8394323_1307525883hHW0.jpg" alt=""><blockquote>
<p>以上关于B树的插入，删除内容摘录于<a href="http://blog.csdn.net/v_july_v/article/details/6530142，来源于鼎鼎大名的july大神，算法之道结构之法的作者，他本人的博客质量特别高。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6530142，来源于鼎鼎大名的july大神，算法之道结构之法的作者，他本人的博客质量特别高。</a></p>
</blockquote>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树我觉得最重要的两个特征就是：</p>
<pre><code>1. 内部节点不保存真正的数据，即data域。
2. 有序数组链表，叶子节点用链表连接起来
</code></pre><p>为什么数据索引要用B+树而不是B树</p>
<ol>
<li><strong>B+树还有一个最大的好处，方便扫库</strong>，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因</li>
<li>mysql 底层存储是用B+树实现的，知道为什么么。内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了。</li>
<li>B+tree的内部结点并没有存储信息。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<h3 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h3></li>
</ol>
<p>R树就很好的解决了高维空间搜索问题。它把B树的思想很好的扩展到了多维空间。希望以后有时间能够仔细研究下。这里先mark一下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangamama.github.io/hh.github.io/hh.github.io/2017/09/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="号号(个人邮箱a981945164@163.com，不当之处请指正)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hh.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="src">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hh.github.io/2017/09/12/hello-world/" itemprop="url">我的博客开播了</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T13:12:39+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为什么要写博客呢？</p>
<ol>
<li>做技术的积累与沉淀，好记性不如烂笔头</li>
<li>善于总结，是一个善于学习者的必备素质</li>
<li>网上有很多太水的博客，质量太差，自己想写个质量高一点的</li>
<li>表达自己的想法—&gt;得到反馈—&gt;反思，修正，提高</li>
<li>对自己博客的期望： 简洁，直白，原创，排版美观，坚持(持续更新)</li>
<li>博客要写什么内容: 技术为主（java，网站架构，机器学习相关），个人感受，影评书评之类的</li>
<li>如果想联系我，email(a981945164@163.com)</li>
</ol>
<h3 id="目录，持续更新中"><a href="#目录，持续更新中" class="headerlink" title="目录，持续更新中"></a>目录，持续更新中</h3><p>首先会将自己以前的积累慢慢整理发布上来，以下为列出的初步目录。</p>
<ul>
<li><p><a href="">谈谈自己在阿里实习的感受</a></p>
</li>
<li><p><a href="https://wangamama.github.io/hh.github.io/2017/09/13/%E8%B0%88%E8%B0%88Mysql%E7%9A%84%E7%B4%A2%E5%BC%95/">谈谈Mysql的索引</a></p>
</li>
<li><p><a href="https://wangamama.github.io/hh.github.io/2017/09/17/sql%E4%BC%98%E5%8C%96/">Mysql的sql优化</a></p>
</li>
<li><p><a href="https://wangamama.github.io/hh.github.io/2017/09/19/%E8%B0%88%E8%B0%88Mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/">谈谈Mysql表结构的设计(如何存储URL等)</a></p>
</li>
<li><p>网站安全的那些事</p>
</li>
<li><p>PRML(Pattern Recognition and Machine Learning)读书笔记, 这本书读的我好累</p>
</li>
<li><p>常见的机器学习算法原理与优缺点的总结</p>
</li>
<li><p>关于spring中IOC和AOP的理解</p>
</li>
<li><p>设计模式</p>
</li>
<li><p>谈谈spring里面的设计模式</p>
</li>
<li><p>在数据量比较大的情况下，如何使用hibernate</p>
</li>
<li><p>基于ACL和RBAC怎么做权限模型的设计</p>
</li>
<li><p>shiro的入门贴</p>
</li>
<li><p>ngnix+tomcat+memcached如何做负载均衡</p>
</li>
<li><p>谈谈乐观锁</p>
</li>
<li><p>如何使用好线程池</p>
</li>
<li><p>关于hash的那些事</p>
</li>
<li><p>如何在你的项目里面使用activiti</p>
</li>
<li><p>如何设计一个大型网站的架构</p>
</li>
<li><p>读读struts2的源码</p>
</li>
<li><p>CLH锁与MCS锁</p>
</li>
<li><p>如何保证接口的幂等性</p>
</li>
<li><p>浅谈微服务</p>
</li>
</ul>
<h3 id="友情支持"><a href="#友情支持" class="headerlink" title="友情支持"></a>友情支持</h3><p>如果你觉得其中某篇文章稍微有点用，或者对你有些许帮助， 友情支持一下，请我喝杯饮料。哈哈</p>
<p><img src="http://ow6dw2tis.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170919163309.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">号号(个人邮箱a981945164@163.com，不当之处请指正)</p>
            <p class="site-description motion-element" itemprop="description">技术沉淀</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/hh.github.io/archives/">
            
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">号号(个人邮箱a981945164@163.com，不当之处请指正)</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/hh.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/hh.github.io/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/hh.github.io/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/hh.github.io/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/hh.github.io/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/hh.github.io/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
