<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/hh.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/hh.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/hh.github.io/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="sql," />








  <link rel="shortcut icon" type="image/x-icon" href="/hh.github.io/favicon.ico?v=5.1.2" />






<meta name="description" content="先胡乱的扯几句，为什么要写这个帖子呢，因为大四的时候发现自己的sql写的不太好，后来项目的网站又有性能优化的需求，就主动的断断续续的关注这个问题，下面主要对自己看到的用到的一些内容做一个总结。 为什么查询会变慢最简单的衡量查询开销的三个指标如下：响应时间(服务时间+排队时间(等待IO或者锁))，扫描的行数，返回的行数一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏以此为：在索">
<meta name="keywords" content="sql">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql的sql优化">
<meta property="og:url" content="https://wangamama.github.io/hh.github.io/2017/09/17/sql优化/index.html">
<meta property="og:site_name" content="src">
<meta property="og:description" content="先胡乱的扯几句，为什么要写这个帖子呢，因为大四的时候发现自己的sql写的不太好，后来项目的网站又有性能优化的需求，就主动的断断续续的关注这个问题，下面主要对自己看到的用到的一些内容做一个总结。 为什么查询会变慢最简单的衡量查询开销的三个指标如下：响应时间(服务时间+排队时间(等待IO或者锁))，扫描的行数，返回的行数一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏以此为：在索">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215930054-1343859589.png">
<meta property="og:updated_time" content="2017-09-18T18:37:55.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mysql的sql优化">
<meta name="twitter:description" content="先胡乱的扯几句，为什么要写这个帖子呢，因为大四的时候发现自己的sql写的不太好，后来项目的网站又有性能优化的需求，就主动的断断续续的关注这个问题，下面主要对自己看到的用到的一些内容做一个总结。 为什么查询会变慢最简单的衡量查询开销的三个指标如下：响应时间(服务时间+排队时间(等待IO或者锁))，扫描的行数，返回的行数一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏以此为：在索">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215930054-1343859589.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hh.github.io/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangamama.github.io/hh.github.io/2017/09/17/sql优化/"/>





  <title>Mysql的sql优化 | src</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hh.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">src</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个程序员, 文学爱好者的思考</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hh.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hh.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wangamama.github.io/hh.github.io/hh.github.io/2017/09/17/sql优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="号号(个人邮箱a981945164@163.com，不当之处请指正)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hh.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="src">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Mysql的sql优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-17T22:47:52+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>先胡乱的扯几句，为什么要写这个帖子呢，因为大四的时候发现自己的sql写的不太好，后来项目的网站又有性能优化的需求，就主动的断断续续的关注这个问题，下面主要对自己看到的用到的一些内容做一个总结。</p>
<h2 id="为什么查询会变慢"><a href="#为什么查询会变慢" class="headerlink" title="为什么查询会变慢"></a>为什么查询会变慢</h2><p>最简单的衡量查询开销的三个指标如下：响应时间(服务时间+排队时间(等待IO或者锁))，扫描的行数，返回的行数<br>一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏以此为：<br>在索引中使用 WHERE 条件来过滤不匹配的记录。这是在存储引擎层完成的。<br>使用索引覆盖扫描（在 Extra 列中出现了 Using index）来返回记录，直接从索引中过滤掉不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，但无须再回表查询记录。<br>从数据表中返回数据，然后过滤掉不满足条件的记录（在 Extra 列中出现 Using Where）。这在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤。   </p>
<h2 id="mysql的sql执行原理"><a href="#mysql的sql执行原理" class="headerlink" title="mysql的sql执行原理"></a>mysql的sql执行原理</h2><p><img src="http://images2015.cnblogs.com/blog/943211/201604/943211-20160423215930054-1343859589.png" alt=""><br>以上的图是mysql如何执行查询的原理图。<br><strong><em>存储引擎给查询执行引擎提供了基本的底层接口，存储引擎共有的特性则由服务器层实现，比如时间，日期，函数，视图，触发器等。  </em></strong><br>上图清楚的展示了当我们给Mysql发送一个sql查询，mysql到底做了什么事情？</p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。<br>mysql如何判断缓存是否命中呢？<br>缓存存放在一个引用表中，用一个hash引用，这个哈希值包含了查询本身，客户端的协议版本，要查询的数据库等，特别要注意的是sql中，任何字符上的不同，大小写之类的，任何的不同都会导致缓存不命中。如果查询中包含任何不确定的函数，如NOW(),current_user等,MYSQL不会检查查询缓存。同样innodb的事务也会降低缓存的命中率，因为查询只有在该事务提交之后才会被缓存。<br>mysql不是通过操作系统，而是自己去管理缓存的内存空间，在初始化缓存空间的时候只会调用一次malloc()函数。当查询过来之后，首先找到一个合适的内存块(大于query_cache_min_res_unit，此时并不知道结果需要多大的内存)，等结果查询出来之后，将结果存入其中(不够用还会申请新的内存块)，之后会释放空闲内存，可能还会进行内存的合并。但是还是会出现<strong>内存碎片</strong>的问题。<br>那么到底开启还是关闭mysql的缓存？有时开启缓存反而会降低性能，此时需要关注的是Qcache_hits(缓存命中的次数):Qcache_inserts(缓存插入的次数)的比值大于3:1的时候才认为缓存有作用。对于一些很复杂的sql语句，需要很大的计算(如count()，join)，查询返回的结果比较小，是很适合做缓存的。同时开启缓存，要保证涉及的表上查询比插入更新的场景要多，对于经常更新场景，查询缓存不能带来性能的提升。<br>我个人觉得使用数据库的查询缓存是一件很复杂的事情，尤其是在有事务的情况下。更好的方案是使用应用端的缓存，而不是依赖mysql的查询缓存。</li>
<li>服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="mysql的通信协议"><a href="#mysql的通信协议" class="headerlink" title="mysql的通信协议"></a>mysql的通信协议</h3><p>Mysql服务器和客户端之前的通信采用<strong>半双工</strong>的协议，意思是好比两个人传球，球在某个时间点，只可能被一个人控制。一端发消息后，另一端完全接受到消息才能响应。一个明显的限制是，这意味着没法进行流量控制。一旦一段开始发送消息，另一段要接收完整个消息才能响应它。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。<br>多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。<br>当使用多数连接 MySQL 的库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。这里的意思是，处理 ResultSet 时，数据已经从 MySQL 服务器上读取过来数据，然后直接从 ResultSet 中取数据。<br>MySQL 连接的状态，可以理解为服务器端一个线程，该状态表示了 MySQL 当前正在做什么：<br>Sleep：线程正在等待客户端发送新的请求。<br>Query：线程正在执行查询或者正在将结果发送给客户端。<br>Locked：在 MySQL 服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如 InnoDB 的行锁，并不会体现在线程状态中。<br>Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。<br>Copying to tmp table [on disk]：线程正在执行查询，并且将结果集都复制到一个临时表中，这种状态一般要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有 on disk 标记，那表示 MySQL 正在将一个内存临时表放到磁盘上。<br>Sorting result：线程正在对结果集进行排序。<br>Sending data：这表示多种情况线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p>
<h3 id="mysql的查询优化器"><a href="#mysql的查询优化器" class="headerlink" title="mysql的查询优化器"></a>mysql的查询优化器</h3><p>导致一个查询可能跟我们认为那样不一样的主要原因就是，mysql的查询优化器很复杂。<br>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数（索引中不同值的数量）、索引和数据行的长度、索引分布情况。统计信息可能不准确，还有其他原因会导致MYSQL选择错误的执行计划。<br>优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，可以认为这是一种“编译时优化”。动态优化则和查询的上下文有关，也可能和很多其他因素有关，需要在每次查询时都重新评估，可以认为是“运行时优化”。</p>
<p>查询优化器都能做什么事情呢？  </p>
<ol>
<li>优化器可以定义表关联的顺序，MYSQL查询使用循环嵌套的方式来执行查询，那么先执行大表的查找，再关联小表，循环的次数会更少。 </li>
<li>可以将外join,转化为内部join.  </li>
<li>将5=5 and a&gt;5转化为 a&gt;5, 进行等价变换</li>
<li>优化count(),Min(),MAX();索引很能帮助来进行这类统计，比如寻找最小值，只需要找到最左端的值。特别重要的是，在没有where条件的情况下，count(“*”)直接从存储引擎获取，myISAM将其作为一个变量存起来。</li>
<li>覆盖索引，无需查找对应的行</li>
<li>子查询优化</li>
<li>提前终止查询，比如limit字句。或者where id=-1,直接返回空值。</li>
<li>对in列表优化，会先对in中的列表进行排序，然后使用二分法来验证是否满足某行是否满足该in条件。</li>
</ol>
<h3 id="MySQL关联查询（个人感觉比较重要）"><a href="#MySQL关联查询（个人感觉比较重要）" class="headerlink" title="MySQL关联查询（个人感觉比较重要）"></a>MySQL关联查询（个人感觉比较重要）</h3><p>对于 UNION 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 UNION 查询。</p>
<p>MySQL 关联执行的策略：MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行位置。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL 会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL 返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。可以使用如下代码来解释：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 内关联查询 ----------------------------------------------------</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  tbl1.col1,</div><div class="line">  tbl2.col2</div><div class="line"><span class="keyword">FROM</span> tbl1</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span> (col3)</div><div class="line"><span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 用伪代码来解释 MySQL 关联执行的策略则是如下：</span></div><div class="line">outer_iter = iterator over tbl1 WHERE col1 IN (5, 6)</div><div class="line">outer_row = outer_iter.next</div><div class="line">while outer_row</div><div class="line">    inner_iter = iterator over tbl2 WHERE col3 = outer_row.col3</div><div class="line">    inner_row  = inner_iter.next</div><div class="line">    while inner_row</div><div class="line">        output [outer_row.col1, inner_row.col2]</div><div class="line">        inner_row = inner_iter.next</div><div class="line">    <span class="keyword">end</span></div><div class="line">    outer_row = outer_iter.next</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">-- 左外关联查询 --------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  tbl1.col1,</div><div class="line">  tbl2.col2</div><div class="line"><span class="keyword">FROM</span> tbl1</div><div class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span> (col3)</div><div class="line"><span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 用伪代码来解释 MySQL 关联执行的策略则是如下：</span></div><div class="line">outer_iter = iterator over tbl1 WHERE col1 IN (5, 6)</div><div class="line">outer_row = outer_iter.next</div><div class="line">while outer_row</div><div class="line">    inner_iter = iterator over tbl2 WHERE col3 = outer_row.col3</div><div class="line">    inner_row  = inner_iter.next</div><div class="line">    if inner_row</div><div class="line">        while inner_row</div><div class="line">            output [outer_row.col1, inner_row.col2]</div><div class="line">            inner_row = inner_iter.next</div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">output</span> [outer_row.col1, <span class="literal">NULL</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line">    outer_row = outer_iter.next</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>那么，关联查询优化器是如何工作呢？<br>MySQL 优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。关联查询优化器通过评估不同关联顺序时的成本来选择一个代价最小的关联顺序。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  film.film_id,</div><div class="line">  film.title,</div><div class="line">  film.release_year,</div><div class="line">  actor.actor_id,</div><div class="line">  actor.first_name,</div><div class="line">  actor.last_name</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id) <span class="comment">---使用film_id来查找对应的actor_id</span></div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id) \G  <span class="comment">---使用actor_id来查找对应的记录</span></div><div class="line"></div><div class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: ALL</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></div><div class="line">      key_len: <span class="literal">NULL</span></div><div class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">rows</span>: <span class="number">200</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film_actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span></div><div class="line">possible_keys: PRIMARY,idx_fk_film_id</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.actor.actor_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">27</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></div><div class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: eq_ref</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film_actor.film_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">1</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p>
<p>从这个执行计划就能能看出这个查询是从 actor 开始查询的。对比一下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">EXPLAIN</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span></div><div class="line">  film.film_id,</div><div class="line">  film.title,</div><div class="line">  film.release_year,</div><div class="line">  actor.actor_id,</div><div class="line">  actor.first_name,</div><div class="line">  actor.last_name</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id)</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id) \G</div><div class="line"></div><div class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: ALL</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></div><div class="line">      key_len: <span class="literal">NULL</span></div><div class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">rows</span>: <span class="number">1000</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div><div class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: film_actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span></div><div class="line">possible_keys: PRIMARY,idx_fk_film_id</div><div class="line">          <span class="keyword">key</span>: idx_fk_film_id</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film.film_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">5</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></div><div class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</div><div class="line">           <span class="keyword">id</span>: <span class="number">1</span></div><div class="line">  select_type: SIMPLE</div><div class="line">        <span class="keyword">table</span>: actor</div><div class="line">   <span class="keyword">partitions</span>: <span class="literal">NULL</span></div><div class="line">         <span class="keyword">type</span>: eq_ref</div><div class="line">possible_keys: PRIMARY</div><div class="line">          <span class="keyword">key</span>: PRIMARY</div><div class="line">      key_len: <span class="number">2</span></div><div class="line">          <span class="keyword">ref</span>: sakila.film_actor.actor_id</div><div class="line">         <span class="keyword">rows</span>: <span class="number">1</span></div><div class="line">     filtered: <span class="number">100.00</span></div><div class="line">        Extra: <span class="literal">NULL</span></div></pre></td></tr></table></figure></p>
<p>在这里我们发现STRAIGHT_JOIN之后，将不会使用优化器进行优化，此时的关联顺序与优化后的是相反的，为什么是相反的呢？</p>
<ol>
<li>将film作为第一个表的时候，会找到950条记录，意思是最外层的循环是950次—（1次查询+950次查询）</li>
<li>将actor作为第一个表的时候，最外层的循环是200次—（1次查询+200次查询）</li>
</ol>
<p><strong>当我们被问到两个表关联的时候，那个做主表？</strong><br>答案是：小表做主表，例如a表1条记录，b表10000条记录，连接条件是a.id = b.id,先从a表找就只需要确定b表中有无满足条件的记录，1次就ok,如果先从b表找，就需要找10000次<br>同时还要告诉他：数据库优化引擎会在解析阶段根据索引和统计信息选择合理的执行计划。</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>如果需要排序的数量小于“排序缓冲区”，MySQL 使用内存进行“快速排序”操作。如果内存不够排序，那么 MySQL 会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并merge排序，最后返回排序结果。</p>
<p>还有排序涉及到的一次扫描算法和两次扫描算法，见上一个博客(mysql索引)</p>
<h2 id="各个sql优化场景"><a href="#各个sql优化场景" class="headerlink" title="各个sql优化场景"></a>各个sql优化场景</h2><p><strong>应用与数据库： 数据库擅长于计数，而应用层适合字符串的处理和正则</strong></p>
<h3 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 原始写法</span></div><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line"><span class="keyword">WHERE</span> film_id <span class="keyword">IN</span> (</div><div class="line">  <span class="keyword">SELECT</span> film_id</div><div class="line">  <span class="keyword">FROM</span> film_actor</div><div class="line">  <span class="keyword">WHERE</span> actor_id = <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 改进后的写法</span></div><div class="line"><span class="keyword">SELECT</span> film.*</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span> (film_id)</div><div class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>原始查询为什么慢？<br>首先原始的查询会改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> film</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</div><div class="line">    <span class="keyword">SELECT</span> *</div><div class="line">    <span class="keyword">FROM</span> film_actor</div><div class="line">    <span class="keyword">WHERE</span> actor_id = <span class="number">1</span></div><div class="line">          <span class="keyword">AND</span> film_actor.film_id = film.film_id);</div></pre></td></tr></table></figure>
<p>这是一个相关子查询，如果外层的表film很大，性能将会很差。</p>
<p><em>子查询分为两类：<br>非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询。<br>相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次。</em></p>
<pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> t1.ename,t1.job,t1.sal <span class="keyword">from</span> emp t1  </div><div class="line"><span class="keyword">where</span> t1.sal &gt; (  </div><div class="line">  <span class="keyword">select</span> <span class="keyword">avg</span>(t2.sal) <span class="keyword">from</span> emp t2 <span class="comment">--子查询是一个独立的查询  </span></div><div class="line">);  </div><div class="line"><span class="keyword">select</span> t1.ename,t1.job,t1.sal <span class="keyword">from</span> emp t1  </div><div class="line"><span class="keyword">where</span> t1.sal &gt; (  </div><div class="line">  <span class="keyword">select</span> <span class="keyword">avg</span>(t2.sal) <span class="keyword">from</span> emp t2  </div><div class="line">  <span class="keyword">where</span> t2.deptno=t1.deptno  <span class="comment">--依赖于外部查询结果  </span></div><div class="line">);</div></pre></td></tr></table></figure>
</code></pre><h3 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h3><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">explain</span> <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(actor_id)</div><div class="line">	<span class="keyword">FROM</span> actor</div><div class="line">	<span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span> </div><div class="line">	# <span class="keyword">id</span>, select_type, <span class="keyword">table</span>, <span class="keyword">partitions</span>, <span class="keyword">type</span>, possible_keys, <span class="keyword">key</span>, key_len, <span class="keyword">ref</span>, <span class="keyword">rows</span>, filtered, Extra</div><div class="line">	<span class="string">'1'</span>, <span class="string">'SIMPLE'</span>, <span class="string">'actor'</span>, <span class="literal">NULL</span>, <span class="string">'ALL'</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">'200'</span>, <span class="string">'100.00'</span>, <span class="string">'Using where'</span></div><div class="line">	</div><div class="line">	<span class="string">``</span><span class="string">`   </span></div><div class="line"><span class="string"> </span></div><div class="line"><span class="string">因为first_name并没有索引，如上所示将会全表扫描(type:all),但是实际上我们已经知道使用主键扫描，当 MySQL 读到第一个满足条件的记录的时候，就是我们需要的最小值了。所以以上的sql可以被改写为：</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">	`</span><span class="string">``</span><span class="keyword">sql</span></div><div class="line">	<span class="keyword">SELECT</span> actor_id</div><div class="line">	<span class="keyword">FROM</span> actor</div><div class="line">	<span class="keyword">USE</span> <span class="keyword">INDEX</span> (PRIMARY)</div><div class="line">	<span class="keyword">WHERE</span> first_name = <span class="string">'PENELOPE'</span></div><div class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span>;</div><div class="line">    ``` </div><div class="line"></div><div class="line">一个容易产生的误解：MyISAM 的 COUNT() 函数总是非常快，不过这是有前提条件的，即只有没有任何 WHERE 条件的 COUNT(*) 才非常快。MySQL 利用存储引擎的特性直接获取这个值。</div><div class="line">如果 MySQL 知道某个列 col 不可能为 NULL 值，那么 MySQL 内部会将 COUNT(col) 表达式转化为 COUNT(*)。</div><div class="line">虽然上面的查询type依然是ALL，但是可以减少扫描行数。</div><div class="line">一个优化的例子如下所示:</div><div class="line"></div><div class="line">	```sql</div><div class="line">	<span class="comment">-- 没有优化的 SQL，需要扫描大多数行</span></div><div class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</div><div class="line">	<span class="keyword">FROM</span> city</div><div class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">5</span>;</div><div class="line">	</div><div class="line">	<span class="comment">-- 优化后的 SQL，只需要扫描少量的行,这里可以优化的原因是SELECT COUNT(*) FROM city在查询优化器中会被转化为常量处理</span></div><div class="line">	<span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</div><div class="line">	        <span class="keyword">FROM</span> city) - <span class="keyword">COUNT</span>(*)</div><div class="line">	<span class="keyword">FROM</span> city</div><div class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span> &lt;= <span class="number">5</span>;</div><div class="line">	</div><div class="line">	<span class="comment">-- 如何在一个sql查询不同颜色的数量,不满足条件的设置为null就OK了</span></div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  <span class="keyword">COUNT</span>(color = <span class="string">'blue'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> blue,</div><div class="line">	  <span class="keyword">COUNT</span>(color = <span class="string">'red'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>)  <span class="keyword">AS</span> red</div><div class="line">	<span class="keyword">FROM</span> items;</div><div class="line">	``` </div><div class="line"></div><div class="line">### 关联的时候如何建立索引</div><div class="line"></div><div class="line">  确保 ON 或者 USING 子句的列上有索引。当A，B两个表用c做关联的时候，如果优化器的关联顺序是B(B是小表)，A，那么只需要在A表上的c列上建立索引。</div><div class="line"></div><div class="line">### 优化 GROUP BY 和 DISTINCT</div><div class="line"></div><div class="line">在 MySQL 中，当无法使用索引的时候， GROUP BY 使用两种策略来完成：使用临时表或者文件排序来分组。</div><div class="line">一个优化的例子如下所示：</div><div class="line">	```sql</div><div class="line">	<span class="comment">-- 这个查询效率不会很好</span></div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  actor.first_name,</div><div class="line">	  actor.last_name,</div><div class="line">	  <span class="keyword">COUNT</span>(*)</div><div class="line">	<span class="keyword">FROM</span> film_actor</div><div class="line">	  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</div><div class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> actor.first_name, actor.last_name;</div><div class="line">	<span class="comment">-- 这个查询的效率更高，如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组的效果会比其他列更高</span></div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  actor.first_name,</div><div class="line">	  actor.last_name,</div><div class="line">	  <span class="keyword">COUNT</span>(*)</div><div class="line">	<span class="keyword">FROM</span> film_actor</div><div class="line">	  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> actor <span class="keyword">USING</span> (actor_id)</div><div class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> film_actor.actor_id;</div><div class="line">	``` </div><div class="line"></div><div class="line">### 使用用户自定义变量的场景</div><div class="line"></div><div class="line">用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信。</div><div class="line">使用用户自定义变量的一个重要特性是可以在给一个变量赋值的同时使用这个变量。</div><div class="line">	```sql</div><div class="line">	<span class="comment">---使用变量显示行号</span></div><div class="line">	<span class="keyword">SET</span> @<span class="keyword">rownum</span> := <span class="number">0</span>;</div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  actor_id,</div><div class="line">	  @<span class="keyword">rownum</span> := @<span class="keyword">rownum</span> + <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">rownum</span></div><div class="line">	<span class="keyword">FROM</span> actor</div><div class="line">	<span class="keyword">LIMIT</span> <span class="number">3</span>;</div><div class="line">	</div><div class="line">	<span class="comment">---下面的例子是找出电影数量最多的10个演员，要求是当电影数量一样的时候，排名一样。</span></div><div class="line">	<span class="keyword">SET</span> @curr_cnt := <span class="number">0</span>, @prev_cnt := <span class="number">0</span>, @<span class="keyword">rank</span> := <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  actor_id,</div><div class="line">	  @curr_cnt := cnt                                          <span class="keyword">AS</span> cnt,<span class="comment">---当前这个演员的电影数量</span></div><div class="line">	  @<span class="keyword">rank</span>     := <span class="keyword">if</span>(@prev_cnt &lt;&gt; @curr_cnt, @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span>) <span class="keyword">AS</span> <span class="keyword">rank</span>,<span class="comment">---当前这个演员的电影数量与上一个排名的电影数量不一样的时候，rank才加1</span></div><div class="line">	  @prev_cnt := @curr_cnt                                    <span class="keyword">AS</span> dummy</div><div class="line">	<span class="keyword">FROM</span> (</div><div class="line">	   <span class="keyword">SELECT</span></div><div class="line">	     actor_id,</div><div class="line">	     <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt</div><div class="line">	   <span class="keyword">FROM</span> film_actor</div><div class="line">	   <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id</div><div class="line">	   <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span></div><div class="line">	   <span class="keyword">LIMIT</span> <span class="number">10</span></div><div class="line">	) <span class="keyword">AS</span> der;</div><div class="line">	</div><div class="line">	<span class="comment">---更新行的同时返回行的信息，相当于java里面的addAndGet()</span></div><div class="line">	<span class="comment">-- 常规做法</span></div><div class="line">	<span class="keyword">UPDATE</span> tbl <span class="keyword">SET</span> tbl.lastupdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">	<span class="keyword">SELECT</span> lastupdated <span class="keyword">FROM</span> tbl <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line">	<span class="comment">-- 使用变量，无须访问数据表，更高效</span></div><div class="line">	<span class="keyword">UPDATE</span> tbl <span class="keyword">SET</span> tbl.lastupdated = <span class="keyword">NOW</span>() <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">now</span> := <span class="keyword">NOW</span>();</div><div class="line">	<span class="keyword">SELECT</span> @<span class="keyword">now</span>;</div><div class="line">	</div><div class="line">	<span class="comment">---将用户分为热门用户和归档用户。查询用户时，热门用户中查不出来才去查归档用户，避免不必要的 UNION 子查询。</span></div><div class="line">	<span class="comment">-- 查询用户，热门用户中查不出来则查归档用户</span></div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  <span class="keyword">greatest</span>(@<span class="keyword">found</span> := <span class="number">-1</span>, <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span>,<span class="comment">--GREATEST()函数返回输入参数(n1, n2, n3, 等)组的最大值</span></div><div class="line">	  <span class="string">'users'</span>                    <span class="keyword">AS</span> which_tbl</div><div class="line">	<span class="keyword">FROM</span> <span class="keyword">users</span></div><div class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span></div><div class="line">	</div><div class="line">	<span class="keyword">UNION</span> ALL</div><div class="line">	</div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  <span class="keyword">id</span>,</div><div class="line">	  <span class="string">'users_archived'</span> <span class="keyword">AS</span> which_tbl</div><div class="line">	<span class="keyword">FROM</span> users_archived</div><div class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> @<span class="keyword">found</span> <span class="keyword">IS</span> <span class="literal">NULL</span></div><div class="line">	</div><div class="line">	<span class="keyword">UNION</span> ALL</div><div class="line">	<span class="comment">-- 将变量充值，避免影响下次查询</span></div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">	  <span class="number">1</span>,</div><div class="line">	  <span class="string">'reset'</span></div><div class="line">	<span class="keyword">FROM</span> dual <span class="comment">---dual虚拟表</span></div><div class="line">	<span class="keyword">WHERE</span> (@<span class="keyword">found</span> := <span class="literal">NULL</span>) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>当使用group by的时候，结果会自动根据分组的字段进行排序，如果不在乎顺序，而这种默认的排序使用的文件排序，那么使用order by null.也可以直接在group by后面加acs,desc</li>
<li>如果需要重复使用大型表中的某个数据集，那么建立临时表是很好的选择，如果使用到了临时表，需要显示的删除先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>对select *保持怀疑态度，大部分情况下，这种查询都是错误的。  </li>
<li>使用union all代替or,一般情况下一定要使用union all,这样会避免在临时表中去重复，会极大的提高性能。  </li>
<li>Like很慢，有必要的话使用fulltext全文索引</li>
<li>确保group和order by中的表达式只涉及一个表的列</li>
<li>关于分页的优化，在上一节讲过，就是利用延迟关联的思想，要解决的问题就是当偏移量特别大的时候，扫描的性能很差，可以使用索引覆盖扫描，让查询更快<br>– 延迟关联，大大提升查询效率<pre><code class="sql"><span class="keyword">SELECT</span>
film_id,
description
<span class="keyword">FROM</span> film
<span class="keyword">INNER</span> <span class="keyword">JOIN</span> (
    <span class="keyword">SELECT</span> film_id
    <span class="keyword">FROM</span> film
    <span class="keyword">ORDER</span> <span class="keyword">BY</span> title
    <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">5</span>
  ) <span class="keyword">AS</span> lim <span class="keyword">USING</span> (film_id);
</code></pre>
但是很多优化的策略并不是绝对的，我觉得需要用explain进行分析。<br>同样将某个很复杂的查询进行分解，将会减少锁的竞争。让应用层做更多的事，或者更擅长的事，也是一个很好的策略。将某些逻辑处理交给应用层处理也很有帮助。</li>
<li>将查询分解，将查询分解后，执行单个查询可以减少锁的竞争。在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。可以减少冗余记录的查询。这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。某些场景哈希关联的效率要高很多。</li>
<li><strong>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配</strong>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<h3 id="范围查询如何使用索引"><a href="#范围查询如何使用索引" class="headerlink" title="范围查询如何使用索引"></a>范围查询如何使用索引</h3>这里有个很重要的技巧就是<strong>使用in来满足索引的最左匹配</strong>，当我们使用某个索引进行范围的查询那么，其后续的索引就无法用来做排序了，此时就会使用filesort。如何避免这种情况呢？<br>就是通过in来满足最多前缀，比如现在有索引(sex,age),我们希望对age排序，可以使用where sex in(‘m’,’f’) order by age。为什么age建立了索引，因为基本的查询都会查询性别，所以sex 虽然选择性不高，作为索引，可以满足覆盖索引。这跟我们前面讲到的有冲突。这里强调的是通过in()可以满足最左前缀。但是不能滥用，如果In里面的列表太大，就会有性能问题。</li>
</ol>
<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>type:<br>表示MySQL在表中找到所需行的方式，又称“访问类型”，常见类型如下:<br>ALL, index,  range, ref, eq_ref, const, system, NULL从左到右，性能从最差到最好<br>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行<br>index：Full Index Scan，index与ALL区别为index类型只遍历索引树<br>range:索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行。显而易见的索引范围扫描是带有between或者where子句里带有&lt;, &gt;查询。当mysql使用索引去查找一系列值时，例如IN()和OR列表，也会显示range（范围扫描）,当然性能上面是有差异的。<br>ref：使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行<br>eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件<br>const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量<br>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<p>Extra:包含不适合在其他列中显示但十分重要的额外信息<br>Using index:该值表示相应的select操作中使用了覆盖索引（Covering Index）<br>Using where:<br>表示mysql服务器将在存储引擎检索行后再进行过滤。许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where字句的查询都会显示”Using where”。有时”Using where”的出现就是一个暗示：查询可受益于不同的索引。<br>Using temporary：<br>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询<br>Using filesort：<br>MySQL中无法利用索引完成的排序操作称为“文件排序”<br>Using join buffer：<br>强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>很容易把 Extra 列的 “Using index” 和 type 列的 “index” 搞混淆。其实这两者完全不同， type 列和覆盖索引毫无关系；它只是表示这个查询访问数据的方式，或者说是 MySQL 查找行的方式。 MySQL 手册中称之为连接方式（join type）<br>取最大值或者最小值时，如果有索引，则可以直接从 B-Tree 索引的两端取数据，在 EXPLAIN 中就可以看到 Select tables optimized away。从字面意思可以看出，它表示优化器已经从执行计划中移除了该表，并以一个常数取而代之</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>如果你能清晰的看出下面几道题是否能使用索引，那么索引的知识就基本掌握了：</p>
<p>索引(user_id,msg_id)<br>ordey by user_id             Yes<br>ordey by user_id,msg_id      Yes<br>user_id=5 ordey by msg_id      Yes<br>user_id&gt;5 ordey by msg_id      部分<br>user_id&gt;5 ordey by user_id，msg_id      YES<br>ordey by msg_id            No<br>ordey by user_id desc ,msg_id  asc 部分</p>
<p>user_id=5            yes<br>user_id between 5 and 10   yes<br>user_id=5 and msg_id between 5 and 10   yes<br>user_id=5 between 5 and 10 and msg_id=5   部分<br>user_id In(5,6,7) and msg_id=5  yes————-<strong>这个就是我提到的用in来满足最左前缀的策略，相当有用</strong><br>msg_id=5       No<br>user_id=5 and msg_id&gt;5  and msg=”hello”   部分</p>
<p><strong>[美团团队写的慢sql的案例(可以参考)]</strong>(<a href="https://tech.meituan.com/mysql-index.html](https://tech.meituan.com/mysql-index.html" target="_blank" rel="external">https://tech.meituan.com/mysql-index.html](https://tech.meituan.com/mysql-index.html</a>)</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/hh.github.io/tags/sql/" rel="tag"># sql</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/hh.github.io/2017/09/13/谈谈Mysql的索引/" rel="next" title="谈谈Mysql的索引">
                <i class="fa fa-chevron-left"></i> 谈谈Mysql的索引
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">号号(个人邮箱a981945164@163.com，不当之处请指正)</p>
            <p class="site-description motion-element" itemprop="description">技术沉淀</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/hh.github.io/archives/">
            
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么查询会变慢"><span class="nav-number">1.</span> <span class="nav-text">为什么查询会变慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql的sql执行原理"><span class="nav-number">2.</span> <span class="nav-text">mysql的sql执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql的通信协议"><span class="nav-number">2.1.</span> <span class="nav-text">mysql的通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql的查询优化器"><span class="nav-number">2.2.</span> <span class="nav-text">mysql的查询优化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL关联查询（个人感觉比较重要）"><span class="nav-number">2.3.</span> <span class="nav-text">MySQL关联查询（个人感觉比较重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序优化"><span class="nav-number">2.4.</span> <span class="nav-text">排序优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各个sql优化场景"><span class="nav-number">3.</span> <span class="nav-text">各个sql优化场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关联子查询"><span class="nav-number">3.1.</span> <span class="nav-text">关联子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大值和最小值优化"><span class="nav-number">3.2.</span> <span class="nav-text">最大值和最小值优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">3.3.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范围查询如何使用索引"><span class="nav-number">3.4.</span> <span class="nav-text">范围查询如何使用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPLAIN"><span class="nav-number">3.5.</span> <span class="nav-text">EXPLAIN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习题"><span class="nav-number">4.</span> <span class="nav-text">练习题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">号号(个人邮箱a981945164@163.com，不当之处请指正)</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/hh.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hh.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/hh.github.io/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/hh.github.io/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/hh.github.io/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/hh.github.io/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/hh.github.io/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/hh.github.io/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/hh.github.io/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
